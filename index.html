<!doctype html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Three.js Pentagonal Gallery with PLY</title>
    <style>
      html, body { margin: 0; height: 100%; overflow: hidden; background: #ffffff; }
      #info {
        position: absolute; top: 10px; left: 10px; color: #e6e6e6; font: 13px/1.3 system-ui, -apple-system, Segoe UI, Roboto, Arial;
        background: rgba(0,0,0,0.45); padding: 8px 10px; border-radius: 8px; user-select: none;
      }
      #info a { color: #9dd7ff; text-decoration: none; }
      #ui {
        position: absolute; top: 10px; right: 10px; color: #e6e6e6; font: 12px/1.25 system-ui, -apple-system, Segoe UI, Roboto, Arial;
        background: rgba(0,0,0,0.55); padding: 10px 12px; border-radius: 10px; width: 280px; box-shadow: 0 4px 16px rgba(0,0,0,0.25);
        max-height: calc(100vh - 20px); overflow-y: auto; backdrop-filter: blur(4px);
      }
      #ui .row { display: grid; grid-template-columns: 1fr 3fr 48px; gap: 8px; align-items: center; margin: 6px 0; }
      #ui label { color: #c9d1d9; }
      #ui input[type="range"] { width: 100%; }
      #ui .val { text-align: right; font-variant-numeric: tabular-nums; color: #9fb3c8; }
      #ui .section { margin-top: 10px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.15); }
      #ui .title { font-weight: 600; color: #dce2ea; margin-bottom: 4px; letter-spacing: .02em; }
    </style>
    <!-- Using ES modules from CDN (examples/jsm) -->
  </head>
  <body>
    <div id="info">
      <div>마우스 드래그: 회전 · 휠: 줌 · 우클릭: 팬</div>
      <div>이미지: <code>resources/image/1.png..5.png</code> · PLY: <code>resources/ply/1.ply..5.ply</code></div>
    </div>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.159.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.159.0/examples/jsm/"
        }
      }
    </script>
    <script type="module">
      import * as THREE from 'three';
      import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
      import { PLYLoader } from 'three/addons/loaders/PLYLoader.js';

      // ----- basic scene -----
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0xffffff);

      const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 1.6, 7);

      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      document.body.appendChild(renderer.domElement);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.06;
      controls.minDistance = 2.2;
      controls.maxDistance = 20;
      controls.target.set(0, 0, 0);

      // ----- lighting -----
      const hemi = new THREE.HemisphereLight(0xffffff, 0x111122, 0.6);
      scene.add(hemi);
      const dir = new THREE.DirectionalLight(0xffffff, 0.9);
      dir.position.set(5, 6, 4);
      scene.add(dir);

      // ----- center red sphere -----
      const SPHERE_BASE_RADIUS = 0.5; // default/base; UI scales this
      const sphereGeo = new THREE.SphereGeometry(SPHERE_BASE_RADIUS, 48, 32);
      const sphereMat = new THREE.MeshStandardMaterial({ color: 0xff3333, roughness: 0.6, metalness: 0.05 });
      const sphere = new THREE.Mesh(sphereGeo, sphereMat);
      sphere.castShadow = false;
      sphere.receiveShadow = false;
      scene.add(sphere);

      // ----- layout parameters -----
      const COUNT = 5;
      const PLY_OFFSET = 0.28; // how much further the PLY sits behind the image (away from center)
      const ELEVATION = 0.0; // y-position for both images and PLYs
      const DEG2RAD = Math.PI / 180;
      const RAD2DEG = 180 / Math.PI;
      const DEFAULTS = { centerSize: 1.25, ringRadius: 2.8, spriteHeight: 2.0, pointSize: 3.0, pointScale: 1.0, bgColor: '#ffffff', useCenterImage: true, globalYaw: 0, globalPitch: 0, globalRoll: 0, globalH: 0 };
      const params = { ...DEFAULTS };
      // Default yaw per PLY (deg) to face edge tangent, normalized to [0, 360)
      const DEFAULT_PLY_YAW_DEG = Array.from({ length: COUNT }, (_, k) => {
        const angleVertex = (k / COUNT) * Math.PI * 2 - Math.PI / 2;
        const angle = angleVertex + Math.PI / COUNT; // edge midpoint
        const yaw = -angle; // atan2(-sin(angle), cos(angle)) = -angle
        const deg = (yaw * RAD2DEG) % 360;
        return (deg + 360) % 360;
      });
      const norm360 = (deg) => ((deg % 360) + 360) % 360;
      params.plyYaw = DEFAULT_PLY_YAW_DEG.map(norm360);
      params.plyPitch = Array.from({ length: COUNT }, () => 0);
      params.plyRoll = Array.from({ length: COUNT }, () => 0);
      params.plyH = Array.from({ length: COUNT }, () => 0);

      const DEFAULT_ARR = {
        yaw: DEFAULT_PLY_YAW_DEG.map(norm360),
        pitch: Array.from({ length: COUNT }, () => 0),
        roll: Array.from({ length: COUNT }, () => 0),
        h: Array.from({ length: COUNT }, () => 0),
      };

      // ---- URL query parsing ----
      function parseArrayCSV(str, len, normFn) {
        const parts = String(str).split(',');
        const out = new Array(len);
        for (let i = 0; i < len; i++) {
          const v = parseFloat(parts[i]);
          out[i] = isNaN(v) ? 0 : (normFn ? normFn(v) : v);
        }
        return out;
      }
      function loadParamsFromURL() {
        const q = new URLSearchParams(window.location.search);
        const num = (k) => q.has(k) ? parseFloat(q.get(k)) : undefined;
        const bool = (k) => q.has(k) ? (/^(1|true|on)$/i.test(q.get(k))) : undefined;
        const str = (k) => q.get(k);
        const vCenterSize = num('centerSize'); if (!isNaN(vCenterSize)) params.centerSize = vCenterSize;
        const vRing = num('ringRadius'); if (!isNaN(vRing)) params.ringRadius = vRing;
        const vSprite = num('spriteHeight'); if (!isNaN(vSprite)) params.spriteHeight = vSprite;
        const vPtSize = num('pointSize'); if (!isNaN(vPtSize)) params.pointSize = vPtSize;
        const vPtScale = num('pointScale'); if (!isNaN(vPtScale)) params.pointScale = vPtScale;
        const vBG = str('bgColor'); if (vBG) params.bgColor = vBG;
        const vCenterImg = bool('useCenterImage'); if (typeof vCenterImg === 'boolean') params.useCenterImage = vCenterImg;
        const vGY = num('globalYaw'); if (!isNaN(vGY)) params.globalYaw = norm360(vGY);
        const vGR = num('globalRoll'); if (!isNaN(vGR)) params.globalRoll = norm360(vGR);
        const vGP = num('globalPitch'); if (!isNaN(vGP)) params.globalPitch = norm360(vGP);
        const vGH = num('globalH'); if (!isNaN(vGH)) params.globalH = norm360(vGH);
        if (q.has('yaw')) params.plyYaw = parseArrayCSV(q.get('yaw'), COUNT, (d) => norm360(d));
        if (q.has('roll')) params.plyRoll = parseArrayCSV(q.get('roll'), COUNT, (d) => norm360(d));
        if (q.has('pitch')) params.plyPitch = parseArrayCSV(q.get('pitch'), COUNT, (d) => norm360(d));
        if (q.has('h')) params.plyH = parseArrayCSV(q.get('h'), COUNT, (d) => norm360(d));
      }
      loadParamsFromURL();

      const group = new THREE.Group();
      scene.add(group);
      const pcGroup = new THREE.Group(); // holds only the point clouds
      group.add(pcGroup);
      let centerSprite = null;
      let centerSpriteAspect = 1;

      // helpers
      const texLoader = new THREE.TextureLoader();
      const plyLoader = new PLYLoader();

      // storage for created meshes for interactive updates
      const planes = new Array(COUNT); // { mesh, aspect }
      const models = new Array(COUNT); // { mesh }

      function polarPosition(radius, angle, y = 0) {
        return new THREE.Vector3(
          Math.cos(angle) * radius,
          y,
          Math.sin(angle) * radius
        );
      }

      function updateCenter() {
        const size = params.centerSize;
        // Toggle visibility
        sphere.visible = !params.useCenterImage;
        if (centerSprite) centerSprite.visible = !!params.useCenterImage;
        // Sizes
        const sphereScale = size / SPHERE_BASE_RADIUS;
        sphere.scale.setScalar(sphereScale);
        if (centerSprite) {
          centerSprite.scale.set(size * centerSpriteAspect, size, 1);
          centerSprite.position.set(0, 0, 0);
        }
      }

      function updateLayout() {
        updateCenter();

        // Global rotation now applies per point cloud about its own center (handled below)
        pcGroup.rotation.set(0, 0, 0);

        for (let k = 0; k < COUNT; k++) {
          const angleVertex = (k / COUNT) * Math.PI * 2 - Math.PI / 2;
          const angle = angleVertex + Math.PI / COUNT; // edge midpoint

          const p = planes[k];
          if (p && p.mesh) {
            p.mesh.position.copy(polarPosition(params.ringRadius, angle, ELEVATION));
            p.mesh.lookAt(0, ELEVATION, 0);
            p.mesh.scale.set(params.spriteHeight * p.aspect, params.spriteHeight, 1);
          }

          const m = models[k];
          if (m && m.mesh) {
            m.mesh.position.copy(polarPosition(params.ringRadius + PLY_OFFSET, angle, ELEVATION));
            // Base orientation from Euler (local), then pre-multiply by H-Line (world tangent) axis rotation
            const yawDeg = (params.plyYaw[k] || 0) + (params.globalYaw || 0);
            const pitchDeg = (params.plyPitch[k] || 0) + (params.globalPitch || 0);
            const rollDeg = (params.plyRoll[k] || 0) + (params.globalRoll || 0);
            const qEuler = new THREE.Quaternion().setFromEuler(new THREE.Euler(pitchDeg * DEG2RAD, yawDeg * DEG2RAD, rollDeg * DEG2RAD, 'XYZ'));
            const hAxis = new THREE.Vector3(-Math.sin(angle), 0, Math.cos(angle)).normalize();
            const hDeg = (params.plyH[k] || 0) + (params.globalH || 0);
            const qH = new THREE.Quaternion().setFromAxisAngle(hAxis, hDeg * DEG2RAD);
            const q = qH.multiply(qEuler); // world-axis rotation first
            m.mesh.quaternion.copy(q);
            if (m.baseScale) {
              m.mesh.scale.setScalar(m.baseScale * params.pointScale);
            }
            if (m.mesh.material && 'size' in m.mesh.material) {
              m.mesh.material.size = params.pointSize;
              m.mesh.material.needsUpdate = true;
            }
          }
        }
      }

      function addSpriteWithPLY(index) {
        const i = index + 1; // 1..5
        const angleVertex = (index / COUNT) * Math.PI * 2 - Math.PI / 2; // vertex angle, start at top
        const angle = angleVertex + Math.PI / COUNT; // shift to edge midpoint

        // Image as Plane (PNG) placed at edge midpoint and oriented along edge direction (tangent)
        const pngPath = `resources/image/${i}.png`;
        texLoader.load(
          pngPath,
          (tex) => {
            tex.colorSpace = THREE.SRGBColorSpace;
            const aspect = tex.image ? (tex.image.width / tex.image.height) : 1;
            const geo = new THREE.PlaneGeometry(1, 1); // scale to size later
            const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true, alphaTest: 0.06, depthWrite: false, side: THREE.DoubleSide });
            const plane = new THREE.Mesh(geo, mat);
            plane.position.copy(polarPosition(params.ringRadius, angle, ELEVATION));
            // Face toward center so local X aligns with tangential direction
            plane.lookAt(0, ELEVATION, 0);
            plane.scale.set(params.spriteHeight * aspect, params.spriteHeight, 1);
            group.add(plane);
            planes[index] = { mesh: plane, aspect };
          },
          undefined,
          (err) => {
            console.warn(`PNG 로드 실패: ${pngPath}`, err);
          }
        );

        // PLY (behind the sprite, further from center)
        const plyPath = `resources/ply/${i}.ply`;
        plyLoader.load(
          plyPath,
          (geom) => {
            // Points with per-vertex color; no normals needed
            const mat = new THREE.PointsMaterial({ vertexColors: true, size: params.pointSize, sizeAttenuation: false });
            const points = new THREE.Points(geom, mat);

            // Fit model to a target radius for consistency
            geom.computeBoundingSphere();
            const bs = geom.boundingSphere;
            let baseScale = 1.0;
            if (bs && bs.radius > 0) {
              const target = 0.6; // target bounding sphere radius in world units
              baseScale = target / bs.radius;
            }
            points.scale.setScalar(baseScale * params.pointScale);

            const base = polarPosition(params.ringRadius + PLY_OFFSET, angle, ELEVATION);
            points.position.copy(base);
            // Apply per-PLY + global rotations (deg) plus H-Line (world tangent) axis rotation
            const yawDeg = (params.plyYaw[index] || 0) + (params.globalYaw || 0);
            const pitchDeg = (params.plyPitch[index] || 0) + (params.globalPitch || 0);
            const rollDeg = (params.plyRoll[index] || 0) + (params.globalRoll || 0);
            const qEuler = new THREE.Quaternion().setFromEuler(new THREE.Euler(pitchDeg * DEG2RAD, yawDeg * DEG2RAD, rollDeg * DEG2RAD, 'XYZ'));
            const hAxis = new THREE.Vector3(-Math.sin(angle), 0, Math.cos(angle)).normalize();
            const hDeg = (params.plyH[index] || 0) + (params.globalH || 0);
            const qH = new THREE.Quaternion().setFromAxisAngle(hAxis, hDeg * DEG2RAD);
            const q = qH.multiply(qEuler);
            points.quaternion.copy(q);

            pcGroup.add(points);
            models[index] = { mesh: points, baseScale };
          },
          undefined,
          (err) => {
            console.warn(`PLY 로드 실패: ${plyPath}`, err);
          }
        );
      }

      for (let k = 0; k < COUNT; k++) addSpriteWithPLY(k);

      // center image (billboard) setup
      texLoader.load(
        'resources/image/center.png',
        (tex) => {
          tex.colorSpace = THREE.SRGBColorSpace;
          centerSpriteAspect = tex.image ? (tex.image.width / tex.image.height) : 1;
          const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthWrite: false });
          centerSprite = new THREE.Sprite(mat);
          centerSprite.center.set(0.5, 0.5);
          scene.add(centerSprite);
          // initialize center visibility and size
          updateCenter();
        },
        undefined,
        (err) => { console.warn('center.png 로드 실패: resources/image/center.png', err); }
      );

      // resize
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // animate
      const clock = new THREE.Clock();
      function tick() {
        const dt = clock.getDelta();
        controls.update();
        renderer.render(scene, camera);
        requestAnimationFrame(tick);
      }
      tick();

      // ----- UI (sliders) -----
      const ui = document.createElement('div');
      ui.id = 'ui';
      ui.innerHTML = `
        <div class="section">
          <div class="title">Display</div>
          <div class="row">
            <label for="bgColor">Background</label>
            <input id="bgColor" type="color" value="${params.bgColor}">
            <div class="val" id="bgColorVal">${params.bgColor.toUpperCase()}</div>
          </div>
          <div class="row">
            <label for="useCenterImage">Center Image</label>
            <input id="useCenterImage" type="checkbox" ${params.useCenterImage ? 'checked' : ''}>
            <div class="val" id="useCenterImageVal">${params.useCenterImage ? 'ON' : 'OFF'}</div>
          </div>
          <div class="row">
            <label for="centerSize">Center Size</label>
            <input id="centerSize" type="range" min="0.1" max="3.0" step="0.01" value="${params.centerSize}">
            <div class="val" id="centerSizeVal">${params.centerSize.toFixed(2)}</div>
          </div>
        </div>

        <div class="section">
          <div class="title">Layout</div>
          <div class="row">
            <label for="ringRadius">Image Distance</label>
            <input id="ringRadius" type="range" min="1.0" max="6.0" step="0.01" value="${params.ringRadius}">
            <div class="val" id="ringRadiusVal">${params.ringRadius.toFixed(2)}</div>
          </div>
          <div class="row">
            <label for="spriteHeight">Image Size</label>
            <input id="spriteHeight" type="range" min="0.2" max="2.5" step="0.01" value="${params.spriteHeight}">
            <div class="val" id="spriteHeightVal">${params.spriteHeight.toFixed(2)}</div>
          </div>
        </div>

        <div class="section">
          <div class="title">Point Cloud</div>
          <div class="row">
            <label for="pointSize">Point Size</label>
            <input id="pointSize" type="range" min="1" max="10" step="0.1" value="${params.pointSize}">
            <div class="val" id="pointSizeVal">${params.pointSize.toFixed(1)} px</div>
          </div>
          <div class="row">
            <label for="pointScale">Point Cloud Scale</label>
            <input id="pointScale" type="range" min="0.2" max="10.0" step="0.01" value="${params.pointScale}">
            <div class="val" id="pointScaleVal">${params.pointScale.toFixed(2)}×</div>
          </div>
        </div>

        <div class="section">
          <div class="title">Rotation (Global)</div>
          <div class="row">
            <label for="globalYaw">Global Yaw</label>
            <input id="globalYaw" type="range" min="0" max="360" step="1" value="${params.globalYaw}">
            <div class="val" id="globalYawVal">${params.globalYaw.toFixed(0)}°</div>
          </div>
          <div class="row">
            <label for="globalRoll">Global Roll</label>
            <input id="globalRoll" type="range" min="0" max="360" step="1" value="${params.globalRoll}">
            <div class="val" id="globalRollVal">${params.globalRoll.toFixed(0)}°</div>
          </div>
          <div class="row">
            <label for="globalPitch">Global Pitch</label>
            <input id="globalPitch" type="range" min="0" max="360" step="1" value="${params.globalPitch}">
            <div class="val" id="globalPitchVal">${params.globalPitch.toFixed(0)}°</div>
          </div>
          <div class="row">
            <label for="globalH">Global H-Line</label>
            <input id="globalH" type="range" min="0" max="360" step="1" value="${params.globalH}">
            <div class="val" id="globalHVal">${params.globalH.toFixed(0)}°</div>
          </div>
        </div>

        <div class="section">
          <div class="title">Yaw (Per PLY)</div>
          <div class="row">
            <label for="plyYaw1">PLY 1 Yaw</label>
            <input id="plyYaw1" type="range" min="0" max="360" step="1" value="${params.plyYaw[0].toFixed(0)}">
            <div class="val" id="plyYaw1Val">${params.plyYaw[0].toFixed(0)}°</div>
          </div>
          <div class="row">
            <label for="plyYaw2">PLY 2 Yaw</label>
            <input id="plyYaw2" type="range" min="0" max="360" step="1" value="${params.plyYaw[1].toFixed(0)}">
            <div class="val" id="plyYaw2Val">${params.plyYaw[1].toFixed(0)}°</div>
          </div>
          <div class="row">
            <label for="plyYaw3">PLY 3 Yaw</label>
            <input id="plyYaw3" type="range" min="0" max="360" step="1" value="${params.plyYaw[2].toFixed(0)}">
            <div class="val" id="plyYaw3Val">${params.plyYaw[2].toFixed(0)}°</div>
          </div>
          <div class="row">
            <label for="plyYaw4">PLY 4 Yaw</label>
            <input id="plyYaw4" type="range" min="0" max="360" step="1" value="${params.plyYaw[3].toFixed(0)}">
            <div class="val" id="plyYaw4Val">${params.plyYaw[3].toFixed(0)}°</div>
          </div>
          <div class="row">
            <label for="plyYaw5">PLY 5 Yaw</label>
            <input id="plyYaw5" type="range" min="0" max="360" step="1" value="${params.plyYaw[4].toFixed(0)}">
            <div class="val" id="plyYaw5Val">${params.plyYaw[4].toFixed(0)}°</div>
          </div>
        </div>

        <div class="section">
          <div class="title">Roll (Per PLY)</div>
          <div class="row">
            <label for="plyRoll1">PLY 1 Roll</label>
            <input id="plyRoll1" type="range" min="0" max="360" step="1" value="0">
            <div class="val" id="plyRoll1Val">0°</div>
          </div>
          <div class="row">
            <label for="plyRoll2">PLY 2 Roll</label>
            <input id="plyRoll2" type="range" min="0" max="360" step="1" value="0">
            <div class="val" id="plyRoll2Val">0°</div>
          </div>
          <div class="row">
            <label for="plyRoll3">PLY 3 Roll</label>
            <input id="plyRoll3" type="range" min="0" max="360" step="1" value="0">
            <div class="val" id="plyRoll3Val">0°</div>
          </div>
          <div class="row">
            <label for="plyRoll4">PLY 4 Roll</label>
            <input id="plyRoll4" type="range" min="0" max="360" step="1" value="0">
            <div class="val" id="plyRoll4Val">0°</div>
          </div>
          <div class="row">
            <label for="plyRoll5">PLY 5 Roll</label>
            <input id="plyRoll5" type="range" min="0" max="360" step="1" value="0">
            <div class="val" id="plyRoll5Val">0°</div>
          </div>
        </div>

        <div class="section">
          <div class="title">Pitch (Per PLY)</div>
          <div class="row">
            <label for="plyPitch1">PLY 1 Pitch</label>
            <input id="plyPitch1" type="range" min="0" max="360" step="1" value="0">
            <div class="val" id="plyPitch1Val">0°</div>
          </div>
          <div class="row">
            <label for="plyPitch2">PLY 2 Pitch</label>
            <input id="plyPitch2" type="range" min="0" max="360" step="1" value="0">
            <div class="val" id="plyPitch2Val">0°</div>
          </div>
          <div class="row">
            <label for="plyPitch3">PLY 3 Pitch</label>
            <input id="plyPitch3" type="range" min="0" max="360" step="1" value="0">
            <div class="val" id="plyPitch3Val">0°</div>
          </div>
          <div class="row">
            <label for="plyPitch4">PLY 4 Pitch</label>
            <input id="plyPitch4" type="range" min="0" max="360" step="1" value="0">
            <div class="val" id="plyPitch4Val">0°</div>
          </div>
          <div class="row">
            <label for="plyPitch5">PLY 5 Pitch</label>
            <input id="plyPitch5" type="range" min="0" max="360" step="1" value="0">
            <div class="val" id="plyPitch5Val">0°</div>
          </div>
        </div>

        <div class="section">
          <div class="title">H-Line (Per PLY)</div>
          <div class="row">
            <label for="plyH1">PLY 1 H</label>
            <input id="plyH1" type="range" min="0" max="360" step="1" value="0">
            <div class="val" id="plyH1Val">0°</div>
          </div>
          <div class="row">
            <label for="plyH2">PLY 2 H</label>
            <input id="plyH2" type="range" min="0" max="360" step="1" value="0">
            <div class="val" id="plyH2Val">0°</div>
          </div>
          <div class="row">
            <label for="plyH3">PLY 3 H</label>
            <input id="plyH3" type="range" min="0" max="360" step="1" value="0">
            <div class="val" id="plyH3Val">0°</div>
          </div>
          <div class="row">
            <label for="plyH4">PLY 4 H</label>
            <input id="plyH4" type="range" min="0" max="360" step="1" value="0">
            <div class="val" id="plyH4Val">0°</div>
          </div>
          <div class="row">
            <label for="plyH5">PLY 5 H</label>
            <input id="plyH5" type="range" min="0" max="360" step="1" value="0">
            <div class="val" id="plyH5Val">0°</div>
          </div>
        </div>
      `;
      document.body.appendChild(ui);

      function updateBackground() {
        // Update both scene and page backgrounds
        const c = params.bgColor;
        if (scene.background && scene.background.isColor) {
          scene.background.set(c);
        } else {
          scene.background = new THREE.Color(c);
        }
        document.body.style.background = c;
        document.documentElement.style.background = c;
      }

      function bindSlider(id, key) {
        const el = document.getElementById(id);
        const val = document.getElementById(id + 'Val');
        el.addEventListener('input', () => {
          params[key] = parseFloat(el.value);
          if (key === 'pointSize') {
            val.textContent = params[key].toFixed(1) + ' px';
          } else if (key === 'pointScale') {
            val.textContent = params[key].toFixed(2) + '×';
          } else if (key === 'globalYaw' || key === 'globalPitch' || key === 'globalRoll' || key === 'globalH') {
            val.textContent = params[key].toFixed(0) + '°';
          } else {
            val.textContent = params[key].toFixed(2);
          }
          updateLayout();
          syncURL();
        });
      }
      function bindCheckbox(id, key) {
        const el = document.getElementById(id);
        const val = document.getElementById(id + 'Val');
        const update = () => {
          params[key] = !!el.checked;
          val.textContent = params[key] ? 'ON' : 'OFF';
          updateLayout();
          syncURL();
        };
        el.addEventListener('change', update);
        update();
      }
      function bindAngleSlider(id, arr, idx) {
        const el = document.getElementById(id);
        const val = document.getElementById(id + 'Val');
        el.addEventListener('input', () => {
          let deg = parseFloat(el.value);
          deg = ((deg % 360) + 360) % 360;
          arr[idx] = deg;
          val.textContent = `${deg.toFixed(0)}°`;
          updateLayout();
          syncURL();
        });
      }
      function bindColor(id, key) {
        const el = document.getElementById(id);
        const val = document.getElementById(id + 'Val');
        el.addEventListener('input', () => {
          params[key] = el.value;
          val.textContent = params[key].toUpperCase();
          updateBackground();
          syncURL();
        });
      }
      bindCheckbox('useCenterImage', 'useCenterImage');
      bindSlider('centerSize', 'centerSize');
      bindSlider('ringRadius', 'ringRadius');
      bindSlider('spriteHeight', 'spriteHeight');
      bindSlider('pointSize', 'pointSize');
      bindSlider('pointScale', 'pointScale');
      bindAngleSlider('plyYaw1', params.plyYaw, 0);
      bindAngleSlider('plyPitch1', params.plyPitch, 0);
      bindAngleSlider('plyRoll1', params.plyRoll, 0);
      bindAngleSlider('plyYaw2', params.plyYaw, 1);
      bindAngleSlider('plyPitch2', params.plyPitch, 1);
      bindAngleSlider('plyRoll2', params.plyRoll, 1);
      bindAngleSlider('plyYaw3', params.plyYaw, 2);
      bindAngleSlider('plyPitch3', params.plyPitch, 2);
      bindAngleSlider('plyRoll3', params.plyRoll, 2);
      bindAngleSlider('plyYaw4', params.plyYaw, 3);
      bindAngleSlider('plyPitch4', params.plyPitch, 3);
      bindAngleSlider('plyRoll4', params.plyRoll, 3);
      bindAngleSlider('plyYaw5', params.plyYaw, 4);
      bindAngleSlider('plyPitch5', params.plyPitch, 4);
      bindAngleSlider('plyRoll5', params.plyRoll, 4);
      bindSlider('globalYaw', 'globalYaw');
      bindSlider('globalPitch', 'globalPitch');
      bindSlider('globalRoll', 'globalRoll');
      bindSlider('globalH', 'globalH');
      bindAngleSlider('plyH1', params.plyH, 0);
      bindAngleSlider('plyH2', params.plyH, 1);
      bindAngleSlider('plyH3', params.plyH, 2);
      bindAngleSlider('plyH4', params.plyH, 3);
      bindAngleSlider('plyH5', params.plyH, 4);
      bindColor('bgColor', 'bgColor');
      // initialize background from default
      updateBackground();

      // ---- URL sync (serialize only when deviating from defaults) ----
      function arraysEqual(a, b) {
        if (!a || !b || a.length !== b.length) return false;
        for (let i = 0; i < a.length; i++) if (a[i] !== b[i]) return false;
        return true;
      }
      function round(n, d = 2) {
        const p = Math.pow(10, d);
        return Math.round(n * p) / p;
      }
      function toCSV(arr) {
        return arr.map(v => Math.round(v)).join(',');
      }
      function syncURL() {
        const sp = new URLSearchParams();
        // Scalars
        if (params.centerSize !== DEFAULTS.centerSize) sp.set('centerSize', String(round(params.centerSize)));
        if (params.ringRadius !== DEFAULTS.ringRadius) sp.set('ringRadius', String(round(params.ringRadius)));
        if (params.spriteHeight !== DEFAULTS.spriteHeight) sp.set('spriteHeight', String(round(params.spriteHeight)));
        if (params.pointSize !== DEFAULTS.pointSize) sp.set('pointSize', String(round(params.pointSize, 1)));
        if (params.pointScale !== DEFAULTS.pointScale) sp.set('pointScale', String(round(params.pointScale)));
        if ((params.bgColor || '').toLowerCase() !== (DEFAULTS.bgColor || '').toLowerCase()) sp.set('bgColor', params.bgColor);
        if (params.useCenterImage !== DEFAULTS.useCenterImage) sp.set('useCenterImage', params.useCenterImage ? '1' : '0');
        if (params.globalYaw !== DEFAULTS.globalYaw) sp.set('globalYaw', String(Math.round(params.globalYaw)));
        if (params.globalRoll !== DEFAULTS.globalRoll) sp.set('globalRoll', String(Math.round(params.globalRoll)));
        if (params.globalPitch !== DEFAULTS.globalPitch) sp.set('globalPitch', String(Math.round(params.globalPitch)));
        if (params.globalH !== DEFAULTS.globalH) sp.set('globalH', String(Math.round(params.globalH)));
        // Arrays
        if (!arraysEqual(params.plyYaw, DEFAULT_ARR.yaw)) sp.set('yaw', toCSV(params.plyYaw));
        if (!arraysEqual(params.plyRoll, DEFAULT_ARR.roll)) sp.set('roll', toCSV(params.plyRoll));
        if (!arraysEqual(params.plyPitch, DEFAULT_ARR.pitch)) sp.set('pitch', toCSV(params.plyPitch));
        if (!arraysEqual(params.plyH, DEFAULT_ARR.h)) sp.set('h', toCSV(params.plyH));
        // Replace URL without reloading
        const base = location.origin + location.pathname;
        const query = sp.toString();
        const hash = location.hash || '';
        const url = query ? `${base}?${query}${hash}` : `${base}${hash}`;
        history.replaceState(null, '', url);
      }
    </script>
  </body>
 </html>
