<!doctype html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Three.js Pentagonal Gallery with PLY</title>
    <style>
      html, body { margin: 0; height: 100%; overflow: hidden; background: #ffffff; }
      #info {
        position: absolute; top: 10px; left: 10px; color: #e6e6e6; font: 13px/1.3 system-ui, -apple-system, Segoe UI, Roboto, Arial;
        background: rgba(0,0,0,0.45); padding: 8px 10px; border-radius: 8px; user-select: none;
      }
      #info a { color: #9dd7ff; text-decoration: none; }
      #ui {
        position: absolute; top: 10px; right: 10px; color: #e6e6e6; font: 12px/1.25 system-ui, -apple-system, Segoe UI, Roboto, Arial;
        background: rgba(0,0,0,0.55); padding: 10px 12px; border-radius: 10px; width: 280px; box-shadow: 0 4px 16px rgba(0,0,0,0.25);
        max-height: calc(100vh - 20px); overflow-y: auto; backdrop-filter: blur(4px);
      }
      #ui .row { display: grid; grid-template-columns: 1fr 3fr 48px; gap: 8px; align-items: center; margin: 6px 0; }
      #ui label { color: #c9d1d9; }
      #ui input[type="range"] { width: 100%; }
      #ui .val { text-align: right; font-variant-numeric: tabular-nums; color: #9fb3c8; }
      #ui .section { margin-top: 10px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.15); }
      #ui .title { font-weight: 600; color: #dce2ea; margin-bottom: 4px; letter-spacing: .02em; }
    </style>
    <!-- Using ES modules from CDN (examples/jsm) -->
  </head>
  <body>
    <div id="info">
      <div>마우스 드래그: 회전 · 휠: 줌 · 우클릭: 팬</div>
      <div>이미지: <code>resources/image/1.png..5.png</code> · PLY: <code>resources/ply/1.ply..5.ply</code></div>
    </div>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.159.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.159.0/examples/jsm/"
        }
      }
    </script>
    <script type="module">
      import * as THREE from 'three';
      import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
      import { PLYLoader } from 'three/addons/loaders/PLYLoader.js';

      // ----- basic scene -----
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0xffffff);

      const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 1.6, 7);

      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      document.body.appendChild(renderer.domElement);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.06;
      controls.minDistance = 2.2;
      controls.maxDistance = 20;
      controls.target.set(0, 0, 0);

      // ----- lighting -----
      const hemi = new THREE.HemisphereLight(0xffffff, 0x111122, 0.6);
      scene.add(hemi);
      const dir = new THREE.DirectionalLight(0xffffff, 0.9);
      dir.position.set(5, 6, 4);
      scene.add(dir);

      // ----- center red sphere -----
      const SPHERE_BASE_RADIUS = 0.5; // default/base; UI scales this
      const sphereGeo = new THREE.SphereGeometry(SPHERE_BASE_RADIUS, 48, 32);
      const sphereMat = new THREE.MeshStandardMaterial({ color: 0xff3333, roughness: 0.6, metalness: 0.05 });
      const sphere = new THREE.Mesh(sphereGeo, sphereMat);
      sphere.castShadow = false;
      sphere.receiveShadow = false;
      scene.add(sphere);

      // ----- layout parameters -----
      const COUNT = 5;
      const PLY_OFFSET = 0.28; // default D-LINE length baseline from image to PLY
      const ELEVATION = 0.0; // y-position for both images and PLYs
      const DEG2RAD = Math.PI / 180;
      const RAD2DEG = 180 / Math.PI;
      const DEFAULTS = { centerSize: 1.25, ringRadius: 2.8, spriteHeight: 2.0, pointSize: 3.0, pointScale: 1.0, bgColor: '#ffffff', useCenterImage: true, showLabels: true, imgAlpha: 1.0, globalYaw: 0, globalPitch: 0, globalRoll: 0, globalH: 0, dBase: PLY_OFFSET, globalD: 0, globalUD: 0, globalLR: 0 };
      const params = { ...DEFAULTS };
      // Default yaw per PLY (deg) to face edge tangent, normalized to [0, 360)
      const DEFAULT_PLY_YAW_DEG = Array.from({ length: COUNT }, (_, k) => {
        const angleVertex = (k / COUNT) * Math.PI * 2 - Math.PI / 2;
        const angle = angleVertex + Math.PI / COUNT; // edge midpoint
        const yaw = -angle; // atan2(-sin(angle), cos(angle)) = -angle
        const deg = (yaw * RAD2DEG) % 360;
        return (deg + 360) % 360;
      });
      const norm360 = (deg) => ((deg % 360) + 360) % 360;
      params.plyYaw = DEFAULT_PLY_YAW_DEG.map(norm360);
      params.plyPitch = Array.from({ length: COUNT }, () => 0);
      params.plyRoll = Array.from({ length: COUNT }, () => 0);
      params.plyH = Array.from({ length: COUNT }, () => 0);
      params.plyD = Array.from({ length: COUNT }, () => 0); // D-LINE per-PLY delta
      params.plyUD = Array.from({ length: COUNT }, () => 0); // D-PLINE up/down per-PLY
      params.plyLR = Array.from({ length: COUNT }, () => 0); // D-PLINE left/right per-PLY

      const DEFAULT_ARR = {
        yaw: DEFAULT_PLY_YAW_DEG.map(norm360),
        pitch: Array.from({ length: COUNT }, () => 0),
        roll: Array.from({ length: COUNT }, () => 0),
        h: Array.from({ length: COUNT }, () => 0),
        d: Array.from({ length: COUNT }, () => 0),
        ud: Array.from({ length: COUNT }, () => 0),
        lr: Array.from({ length: COUNT }, () => 0),
        img: Array.from({ length: COUNT }, () => 1),
      };

      // ---- URL query parsing ----
      function parseArrayCSV(str, len, normFn) {
        // Accept both ';' and ',' for backward compatibility
        const parts = String(str).split(/[;,]/);
        const out = new Array(len);
        for (let i = 0; i < len; i++) {
          const v = parseFloat(parts[i]);
          out[i] = isNaN(v) ? 0 : (normFn ? normFn(v) : v);
        }
        return out;
      }
      function loadParamsFromURL() {
        const q = new URLSearchParams(window.location.search);
        const num = (k) => q.has(k) ? parseFloat(q.get(k)) : undefined;
        const bool = (k) => q.has(k) ? (/^(1|true|on)$/i.test(q.get(k))) : undefined;
        const str = (k) => q.get(k);
        const vCenterSize = num('centerSize'); if (!isNaN(vCenterSize)) params.centerSize = vCenterSize;
        const vRing = num('ringRadius'); if (!isNaN(vRing)) params.ringRadius = vRing;
        const vSprite = num('spriteHeight'); if (!isNaN(vSprite)) params.spriteHeight = vSprite;
        const vPtSize = num('pointSize'); if (!isNaN(vPtSize)) params.pointSize = vPtSize;
        const vPtScale = num('pointScale'); if (!isNaN(vPtScale)) params.pointScale = vPtScale;
        const vBG = str('bgColor'); if (vBG) params.bgColor = vBG;
        const vCenterImg = bool('useCenterImage'); if (typeof vCenterImg === 'boolean') params.useCenterImage = vCenterImg;
        const vShowLabels = bool('showLabels'); if (typeof vShowLabels === 'boolean') params.showLabels = vShowLabels;
        const vImgAlpha = num('imgAlpha'); if (!isNaN(vImgAlpha)) params.imgAlpha = Math.max(0, Math.min(1, vImgAlpha));
        const vGD = num('globalD'); if (!isNaN(vGD)) params.globalD = vGD;
        const vGUD = num('globalUD'); if (!isNaN(vGUD)) params.globalUD = vGUD;
        const vGLR = num('globalLR'); if (!isNaN(vGLR)) params.globalLR = vGLR;
        const vDB = num('dBase'); if (!isNaN(vDB)) params.dBase = vDB;
        const vGY = num('globalYaw'); if (!isNaN(vGY)) params.globalYaw = norm360(vGY);
        const vGR = num('globalRoll'); if (!isNaN(vGR)) params.globalRoll = norm360(vGR);
        const vGP = num('globalPitch'); if (!isNaN(vGP)) params.globalPitch = norm360(vGP);
        const vGH = num('globalH'); if (!isNaN(vGH)) params.globalH = norm360(vGH);
        if (q.has('yaw')) params.plyYaw = parseArrayCSV(q.get('yaw'), COUNT, (d) => norm360(d));
        if (q.has('roll')) params.plyRoll = parseArrayCSV(q.get('roll'), COUNT, (d) => norm360(d));
        if (q.has('pitch')) params.plyPitch = parseArrayCSV(q.get('pitch'), COUNT, (d) => norm360(d));
        if (q.has('h')) params.plyH = parseArrayCSV(q.get('h'), COUNT, (d) => norm360(d));
        if (q.has('d')) params.plyD = parseArrayCSV(q.get('d'), COUNT);
        if (q.has('ud')) params.plyUD = parseArrayCSV(q.get('ud'), COUNT);
        if (q.has('lr')) params.plyLR = parseArrayCSV(q.get('lr'), COUNT);
        if (q.has('img')) params.plyImgAlpha = parseArrayCSV(q.get('img'), COUNT, (v) => Math.max(0, Math.min(1, parseFloat(v))));
      }
      loadParamsFromURL();

      const group = new THREE.Group();
      scene.add(group);
      const pcGroup = new THREE.Group(); // holds only the point clouds
      group.add(pcGroup);
      let centerSprite = null;
      let centerSpriteAspect = 1;

      // helpers
      const texLoader = new THREE.TextureLoader();
      const plyLoader = new PLYLoader();

      function makeNumberTexture(n) {
        const dpr = Math.min(window.devicePixelRatio || 1, 2);
        const size = 128 * dpr;
        const canvas = document.createElement('canvas');
        canvas.width = canvas.height = size;
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, size, size);
        // background circle
        const r = size * 0.45;
        ctx.beginPath();
        ctx.arc(size/2, size/2, r, 0, Math.PI*2);
        ctx.fillStyle = 'rgba(0,0,0,0.55)';
        ctx.fill();
        // number
        ctx.fillStyle = '#ffffff';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.font = `${Math.floor(size*0.55)}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
        ctx.fillText(String(n), size/2, size/2);
        const tex = new THREE.CanvasTexture(canvas);
        tex.colorSpace = THREE.SRGBColorSpace;
        tex.needsUpdate = true;
        return tex;
      }

      // storage for created meshes for interactive updates
      const planes = new Array(COUNT); // { mesh, aspect }
      const models = new Array(COUNT); // { mesh }

      function polarPosition(radius, angle, y = 0) {
        return new THREE.Vector3(
          Math.cos(angle) * radius,
          y,
          Math.sin(angle) * radius
        );
      }

      function computePlyPosition(index, angle) {
        const radialDir = new THREE.Vector3(Math.cos(angle), 0, Math.sin(angle));
        const tangent = new THREE.Vector3(-Math.sin(angle), 0, Math.cos(angle));
        const r = params.ringRadius + params.dBase + (params.globalD || 0) + (params.plyD[index] || 0);
        const lr = (params.globalLR || 0) + (params.plyLR[index] || 0);
        const ud = (params.globalUD || 0) + (params.plyUD[index] || 0);
        const pos = radialDir.clone().multiplyScalar(r)
          .addScaledVector(tangent, lr)
          .add(new THREE.Vector3(0, ud, 0));
        return pos;
      }

      function imageAlphaFor(index) {
        const per = (params.plyImgAlpha && params.plyImgAlpha[index] != null) ? params.plyImgAlpha[index] : 1;
        const g = (params.imgAlpha == null ? 1 : params.imgAlpha);
        let a = g * per;
        if (!isFinite(a)) a = 1;
        return Math.max(0, Math.min(1, a));
      }

      function updateCenter() {
        const size = params.centerSize;
        // Toggle visibility
        sphere.visible = !params.useCenterImage;
        if (centerSprite) centerSprite.visible = !!params.useCenterImage;
        // Sizes
        const sphereScale = size / SPHERE_BASE_RADIUS;
        sphere.scale.setScalar(sphereScale);
        if (centerSprite) {
          centerSprite.scale.set(size * centerSpriteAspect, size, 1);
          centerSprite.position.set(0, 0, 0);
        }
      }

      function updateLayout() {
        updateCenter();

        // Global rotation now applies per point cloud about its own center (handled below)
        pcGroup.rotation.set(0, 0, 0);

        for (let k = 0; k < COUNT; k++) {
          const angleVertex = (k / COUNT) * Math.PI * 2 - Math.PI / 2;
          const angle = angleVertex + Math.PI / COUNT; // edge midpoint

          const p = planes[k];
          if (p && p.mesh) {
            p.mesh.position.copy(polarPosition(params.ringRadius, angle, ELEVATION));
            p.mesh.lookAt(0, ELEVATION, 0);
            p.mesh.scale.set(params.spriteHeight * p.aspect, params.spriteHeight, 1);
            // update label size/visibility
            if (p.label) {
              const labelWorld = params.spriteHeight * 0.22;
              // counter-scale to keep label size consistent regardless of plane scale
              p.label.scale.set(
                labelWorld / p.mesh.scale.x,
                labelWorld / p.mesh.scale.y,
                1
              );
              // place near top-center of the image
              p.label.position.set(0, 0.38, 0.001);
              p.label.visible = !!params.showLabels;
            }
            // image opacity
            const per = (params.plyImgAlpha && params.plyImgAlpha[k] != null) ? params.plyImgAlpha[k] : 1;
            const a = Math.max(0, Math.min(1, (params.imgAlpha ?? 1) * per));
            p.mesh.material.transparent = true;
            p.mesh.material.opacity = a;
            p.mesh.material.needsUpdate = true;
          }

          const m = models[k];
          if (m && m.mesh) {
            m.mesh.position.copy(computePlyPosition(k, angle));
            // Base orientation from Euler (local), then pre-multiply by H-Line (world tangent) axis rotation
            const yawDeg = (params.plyYaw[k] || 0) + (params.globalYaw || 0);
            const pitchDeg = (params.plyPitch[k] || 0) + (params.globalPitch || 0);
            const rollDeg = (params.plyRoll[k] || 0) + (params.globalRoll || 0);
            const qEuler = new THREE.Quaternion().setFromEuler(new THREE.Euler(pitchDeg * DEG2RAD, yawDeg * DEG2RAD, rollDeg * DEG2RAD, 'XYZ'));
            const hAxis = new THREE.Vector3(-Math.sin(angle), 0, Math.cos(angle)).normalize();
            const hDeg = (params.plyH[k] || 0) + (params.globalH || 0);
            const qH = new THREE.Quaternion().setFromAxisAngle(hAxis, hDeg * DEG2RAD);
            const q = qH.multiply(qEuler); // world-axis rotation first
            m.mesh.quaternion.copy(q);
            if (m.baseScale) {
              m.mesh.scale.setScalar(m.baseScale * params.pointScale);
            }
            if (m.mesh.material && 'size' in m.mesh.material) {
              m.mesh.material.size = params.pointSize;
              m.mesh.material.needsUpdate = true;
            }
          }
        }
      }

      function addSpriteWithPLY(index) {
        const i = index + 1; // 1..5
        const angleVertex = (index / COUNT) * Math.PI * 2 - Math.PI / 2; // vertex angle, start at top
        const angle = angleVertex + Math.PI / COUNT; // shift to edge midpoint

        // Image as Plane (PNG) placed at edge midpoint and oriented along edge direction (tangent)
        const pngPath = `resources/image/${i}.png`;
        texLoader.load(
          pngPath,
          (tex) => {
            tex.colorSpace = THREE.SRGBColorSpace;
            const aspect = tex.image ? (tex.image.width / tex.image.height) : 1;
            const geo = new THREE.PlaneGeometry(1, 1); // scale to size later
            const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true, alphaTest: 0.06, depthWrite: false, side: THREE.DoubleSide });
            const plane = new THREE.Mesh(geo, mat);
            plane.position.copy(polarPosition(params.ringRadius, angle, ELEVATION));
            // Face toward center so local X aligns with tangential direction
            plane.lookAt(0, ELEVATION, 0);
            plane.scale.set(params.spriteHeight * aspect, params.spriteHeight, 1);
            // initial opacity
            plane.material.opacity = imageAlphaFor(index);
            plane.material.needsUpdate = true;
            group.add(plane);
            // Add label sprite
            const lblTex = makeNumberTexture(i);
            const lblMat = new THREE.SpriteMaterial({ map: lblTex, transparent: true, depthWrite: false, depthTest: false });
            const label = new THREE.Sprite(lblMat);
            label.renderOrder = 10;
            // set small size normalized against parent scale
            const labelWorld = params.spriteHeight * 0.22;
            label.scale.set(labelWorld / plane.scale.x, labelWorld / plane.scale.y, 1);
            label.position.set(0, 0.38, 0.001);
            label.visible = !!params.showLabels;
            plane.add(label);

            planes[index] = { mesh: plane, aspect, label };
            // Apply layout once plane exists (ensures opacity/labels correct if URL provided)
            updateLayout();
          },
          undefined,
          (err) => {
            console.warn(`PNG 로드 실패: ${pngPath}`, err);
          }
        );

        // PLY (behind the sprite, further from center)
        const plyPath = `resources/ply/${i}.ply`;
        plyLoader.load(
          plyPath,
          (geom) => {
            // Points with per-vertex color; no normals needed
            const mat = new THREE.PointsMaterial({ vertexColors: true, size: params.pointSize, sizeAttenuation: false });
            const points = new THREE.Points(geom, mat);

            // Fit model to a target radius for consistency
            geom.computeBoundingSphere();
            const bs = geom.boundingSphere;
            let baseScale = 1.0;
            if (bs && bs.radius > 0) {
              const target = 0.6; // target bounding sphere radius in world units
              baseScale = target / bs.radius;
            }
            points.scale.setScalar(baseScale * params.pointScale);

            points.position.copy(computePlyPosition(index, angle));
            // Apply per-PLY + global rotations (deg) plus H-Line (world tangent) axis rotation
            const yawDeg = (params.plyYaw[index] || 0) + (params.globalYaw || 0);
            const pitchDeg = (params.plyPitch[index] || 0) + (params.globalPitch || 0);
            const rollDeg = (params.plyRoll[index] || 0) + (params.globalRoll || 0);
            const qEuler = new THREE.Quaternion().setFromEuler(new THREE.Euler(pitchDeg * DEG2RAD, yawDeg * DEG2RAD, rollDeg * DEG2RAD, 'XYZ'));
            const hAxis = new THREE.Vector3(-Math.sin(angle), 0, Math.cos(angle)).normalize();
            const hDeg = (params.plyH[index] || 0) + (params.globalH || 0);
            const qH = new THREE.Quaternion().setFromAxisAngle(hAxis, hDeg * DEG2RAD);
            const q = qH.multiply(qEuler);
            points.quaternion.copy(q);

            pcGroup.add(points);
            models[index] = { mesh: points, baseScale };
            // Ensure layout gets applied after model loads (e.g., D/UD/LR from URL)
            updateLayout();
          },
          undefined,
          (err) => {
            console.warn(`PLY 로드 실패: ${plyPath}`, err);
          }
        );
      }

      for (let k = 0; k < COUNT; k++) addSpriteWithPLY(k);

      // center image (billboard) setup
      texLoader.load(
        'resources/image/center.png',
        (tex) => {
          tex.colorSpace = THREE.SRGBColorSpace;
          centerSpriteAspect = tex.image ? (tex.image.width / tex.image.height) : 1;
          const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthWrite: false });
          centerSprite = new THREE.Sprite(mat);
          centerSprite.center.set(0.5, 0.5);
          scene.add(centerSprite);
          // initialize center visibility and size
          updateCenter();
        },
        undefined,
        (err) => { console.warn('center.png 로드 실패: resources/image/center.png', err); }
      );

      // resize
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // animate
      const clock = new THREE.Clock();
      function tick() {
        const dt = clock.getDelta();
        controls.update();
        renderer.render(scene, camera);
        requestAnimationFrame(tick);
      }
      tick();

      // ----- UI (sliders) -----
      const ui = document.createElement('div');
      ui.id = 'ui';
      ui.innerHTML = `
        <div class="section">
          <div class="title">Display</div>
          <div class="row">
            <label for="bgColor">Background</label>
            <input id="bgColor" type="color" value="${params.bgColor}">
            <div class="val" id="bgColorVal">${params.bgColor.toUpperCase()}</div>
          </div>
          <div class="row">
            <label for="showLabels">Image Labels</label>
            <input id="showLabels" type="checkbox" ${params.showLabels ? 'checked' : ''}>
            <div class="val" id="showLabelsVal">${params.showLabels ? 'ON' : 'OFF'}</div>
          </div>
          <div class="row">
            <label for="useCenterImage">Center Image</label>
            <input id="useCenterImage" type="checkbox" ${params.useCenterImage ? 'checked' : ''}>
            <div class="val" id="useCenterImageVal">${params.useCenterImage ? 'ON' : 'OFF'}</div>
          </div>
          <div class="row">
            <label for="centerSize">Center Size</label>
            <input id="centerSize" type="range" min="0.1" max="3.0" step="0.01" value="${params.centerSize}">
            <div class="val" id="centerSizeVal">${params.centerSize.toFixed(2)}</div>
          </div>
        </div>

        <div class="section">
          <div class="title">Image Opacity</div>
          <div class="row">
            <label for="imgAlpha">Global Opacity</label>
            <input id="imgAlpha" type="range" min="0" max="1" step="0.01" value="${params.imgAlpha}">
            <div class="val" id="imgAlphaVal">${params.imgAlpha.toFixed(2)}</div>
          </div>
          <div class="row">
            <label for="img1">Img 1</label>
            <input id="img1" type="range" min="0" max="1" step="0.01" value="${((params.plyImgAlpha&&params.plyImgAlpha[0])||1).toFixed(2)}">
            <div class="val" id="img1Val">${((params.plyImgAlpha&&params.plyImgAlpha[0])||1).toFixed(2)}</div>
          </div>
          <div class="row">
            <label for="img2">Img 2</label>
            <input id="img2" type="range" min="0" max="1" step="0.01" value="${((params.plyImgAlpha&&params.plyImgAlpha[1])||1).toFixed(2)}">
            <div class="val" id="img2Val">${((params.plyImgAlpha&&params.plyImgAlpha[1])||1).toFixed(2)}</div>
          </div>
          <div class="row">
            <label for="img3">Img 3</label>
            <input id="img3" type="range" min="0" max="1" step="0.01" value="${((params.plyImgAlpha&&params.plyImgAlpha[2])||1).toFixed(2)}">
            <div class="val" id="img3Val">${((params.plyImgAlpha&&params.plyImgAlpha[2])||1).toFixed(2)}</div>
          </div>
          <div class="row">
            <label for="img4">Img 4</label>
            <input id="img4" type="range" min="0" max="1" step="0.01" value="${((params.plyImgAlpha&&params.plyImgAlpha[3])||1).toFixed(2)}">
            <div class="val" id="img4Val">${((params.plyImgAlpha&&params.plyImgAlpha[3])||1).toFixed(2)}</div>
          </div>
          <div class="row">
            <label for="img5">Img 5</label>
            <input id="img5" type="range" min="0" max="1" step="0.01" value="${((params.plyImgAlpha&&params.plyImgAlpha[4])||1).toFixed(2)}">
            <div class="val" id="img5Val">${((params.plyImgAlpha&&params.plyImgAlpha[4])||1).toFixed(2)}</div>
          </div>
        </div>

        <div class="section">
          <div class="title">Layout</div>
          <div class="row">
            <label for="ringRadius">Image Distance</label>
            <input id="ringRadius" type="range" min="1.0" max="6.0" step="0.01" value="${params.ringRadius}">
            <div class="val" id="ringRadiusVal">${params.ringRadius.toFixed(2)}</div>
          </div>
          <div class="row">
            <label for="spriteHeight">Image Size</label>
            <input id="spriteHeight" type="range" min="0.2" max="2.5" step="0.01" value="${params.spriteHeight}">
            <div class="val" id="spriteHeightVal">${params.spriteHeight.toFixed(2)}</div>
          </div>
        </div>

        <div class="section">
          <div class="title">Point Cloud</div>
          <div class="row">
            <label for="pointSize">Point Size</label>
            <input id="pointSize" type="range" min="1" max="10" step="0.1" value="${params.pointSize}">
            <div class="val" id="pointSizeVal">${params.pointSize.toFixed(1)} px</div>
          </div>
          <div class="row">
            <label for="pointScale">Point Cloud Scale</label>
            <input id="pointScale" type="range" min="0.2" max="10.0" step="0.01" value="${params.pointScale}">
            <div class="val" id="pointScaleVal">${params.pointScale.toFixed(2)}×</div>
          </div>
        </div>

        <div class="section">
          <div class="title">D-Line (Image → PLY)</div>
          <div class="row">
            <label for="globalD">Global D Length</label>
            <input id="globalD" type="range" min="-2.0" max="2.0" step="0.01" value="${params.globalD}">
            <div class="val" id="globalDVal">${params.globalD.toFixed(2)}</div>
          </div>
          <div class="row">
            <label for="dBase">D Base</label>
            <input id="dBase" type="range" min="0.0" max="2.0" step="0.01" value="${params.dBase}">
            <div class="val" id="dBaseVal">${params.dBase.toFixed(2)}</div>
          </div>
          <div class="row">
            <label for="plyD1">PLY 1 D</label>
            <input id="plyD1" type="range" min="-1.0" max="1.0" step="0.01" value="${(params.plyD[0]||0).toFixed(2)}">
            <div class="val" id="plyD1Val">${(params.plyD[0]||0).toFixed(2)}</div>
          </div>
          <div class="row">
            <label for="plyD2">PLY 2 D</label>
            <input id="plyD2" type="range" min="-1.0" max="1.0" step="0.01" value="${(params.plyD[1]||0).toFixed(2)}">
            <div class="val" id="plyD2Val">${(params.plyD[1]||0).toFixed(2)}</div>
          </div>
          <div class="row">
            <label for="plyD3">PLY 3 D</label>
            <input id="plyD3" type="range" min="-1.0" max="1.0" step="0.01" value="${(params.plyD[2]||0).toFixed(2)}">
            <div class="val" id="plyD3Val">${(params.plyD[2]||0).toFixed(2)}</div>
          </div>
          <div class="row">
            <label for="plyD4">PLY 4 D</label>
            <input id="plyD4" type="range" min="-1.0" max="1.0" step="0.01" value="${(params.plyD[3]||0).toFixed(2)}">
            <div class="val" id="plyD4Val">${(params.plyD[3]||0).toFixed(2)}</div>
          </div>
          <div class="row">
            <label for="plyD5">PLY 5 D</label>
            <input id="plyD5" type="range" min="-1.0" max="1.0" step="0.01" value="${(params.plyD[4]||0).toFixed(2)}">
            <div class="val" id="plyD5Val">${(params.plyD[4]||0).toFixed(2)}</div>
          </div>
        </div>

        <div class="section">
          <div class="title">D-Plane Offsets</div>
          <div class="row">
            <label for="globalUD">Global Up/Down</label>
            <input id="globalUD" type="range" min="-2.0" max="2.0" step="0.01" value="${params.globalUD}">
            <div class="val" id="globalUDVal">${params.globalUD.toFixed(2)}</div>
          </div>
          <div class="row">
            <label for="globalLR">Global Left/Right</label>
            <input id="globalLR" type="range" min="-2.0" max="2.0" step="0.01" value="${params.globalLR}">
            <div class="val" id="globalLRVal">${params.globalLR.toFixed(2)}</div>
          </div>
          <div class="row">
            <label for="plyUD1">PLY 1 Up/Down</label>
            <input id="plyUD1" type="range" min="-1.0" max="1.0" step="0.01" value="${(params.plyUD[0]||0).toFixed(2)}">
            <div class="val" id="plyUD1Val">${(params.plyUD[0]||0).toFixed(2)}</div>
          </div>
          <div class="row">
            <label for="plyLR1">PLY 1 Left/Right</label>
            <input id="plyLR1" type="range" min="-1.0" max="1.0" step="0.01" value="${(params.plyLR[0]||0).toFixed(2)}">
            <div class="val" id="plyLR1Val">${(params.plyLR[0]||0).toFixed(2)}</div>
          </div>
          <div class="row">
            <label for="plyUD2">PLY 2 Up/Down</label>
            <input id="plyUD2" type="range" min="-1.0" max="1.0" step="0.01" value="${(params.plyUD[1]||0).toFixed(2)}">
            <div class="val" id="plyUD2Val">${(params.plyUD[1]||0).toFixed(2)}</div>
          </div>
          <div class="row">
            <label for="plyLR2">PLY 2 Left/Right</label>
            <input id="plyLR2" type="range" min="-1.0" max="1.0" step="0.01" value="${(params.plyLR[1]||0).toFixed(2)}">
            <div class="val" id="plyLR2Val">${(params.plyLR[1]||0).toFixed(2)}</div>
          </div>
          <div class="row">
            <label for="plyUD3">PLY 3 Up/Down</label>
            <input id="plyUD3" type="range" min="-1.0" max="1.0" step="0.01" value="${(params.plyUD[2]||0).toFixed(2)}">
            <div class="val" id="plyUD3Val">${(params.plyUD[2]||0).toFixed(2)}</div>
          </div>
          <div class="row">
            <label for="plyLR3">PLY 3 Left/Right</label>
            <input id="plyLR3" type="range" min="-1.0" max="1.0" step="0.01" value="${(params.plyLR[2]||0).toFixed(2)}">
            <div class="val" id="plyLR3Val">${(params.plyLR[2]||0).toFixed(2)}</div>
          </div>
          <div class="row">
            <label for="plyUD4">PLY 4 Up/Down</label>
            <input id="plyUD4" type="range" min="-1.0" max="1.0" step="0.01" value="${(params.plyUD[3]||0).toFixed(2)}">
            <div class="val" id="plyUD4Val">${(params.plyUD[3]||0).toFixed(2)}</div>
          </div>
          <div class="row">
            <label for="plyLR4">PLY 4 Left/Right</label>
            <input id="plyLR4" type="range" min="-1.0" max="1.0" step="0.01" value="${(params.plyLR[3]||0).toFixed(2)}">
            <div class="val" id="plyLR4Val">${(params.plyLR[3]||0).toFixed(2)}</div>
          </div>
          <div class="row">
            <label for="plyUD5">PLY 5 Up/Down</label>
            <input id="plyUD5" type="range" min="-1.0" max="1.0" step="0.01" value="${(params.plyUD[4]||0).toFixed(2)}">
            <div class="val" id="plyUD5Val">${(params.plyUD[4]||0).toFixed(2)}</div>
          </div>
          <div class="row">
            <label for="plyLR5">PLY 5 Left/Right</label>
            <input id="plyLR5" type="range" min="-1.0" max="1.0" step="0.01" value="${(params.plyLR[4]||0).toFixed(2)}">
            <div class="val" id="plyLR5Val">${(params.plyLR[4]||0).toFixed(2)}</div>
          </div>
        </div>

        <div class="section">
          <div class="title">Rotation (Global)</div>
          <div class="row">
            <label for="globalYaw">Global Yaw</label>
            <input id="globalYaw" type="range" min="0" max="360" step="1" value="${params.globalYaw}">
            <div class="val" id="globalYawVal">${params.globalYaw.toFixed(0)}°</div>
          </div>
          <div class="row">
            <label for="globalRoll">Global Roll</label>
            <input id="globalRoll" type="range" min="0" max="360" step="1" value="${params.globalRoll}">
            <div class="val" id="globalRollVal">${params.globalRoll.toFixed(0)}°</div>
          </div>
          <div class="row">
            <label for="globalPitch">Global Pitch</label>
            <input id="globalPitch" type="range" min="0" max="360" step="1" value="${params.globalPitch}">
            <div class="val" id="globalPitchVal">${params.globalPitch.toFixed(0)}°</div>
          </div>
          <div class="row">
            <label for="globalH">Global H-Line</label>
            <input id="globalH" type="range" min="0" max="360" step="1" value="${params.globalH}">
            <div class="val" id="globalHVal">${params.globalH.toFixed(0)}°</div>
          </div>
        </div>

        <div class="section">
          <div class="title">Yaw (Per PLY)</div>
          <div class="row">
            <label for="plyYaw1">PLY 1 Yaw</label>
            <input id="plyYaw1" type="range" min="0" max="360" step="1" value="${params.plyYaw[0].toFixed(0)}">
            <div class="val" id="plyYaw1Val">${params.plyYaw[0].toFixed(0)}°</div>
          </div>
          <div class="row">
            <label for="plyYaw2">PLY 2 Yaw</label>
            <input id="plyYaw2" type="range" min="0" max="360" step="1" value="${params.plyYaw[1].toFixed(0)}">
            <div class="val" id="plyYaw2Val">${params.plyYaw[1].toFixed(0)}°</div>
          </div>
          <div class="row">
            <label for="plyYaw3">PLY 3 Yaw</label>
            <input id="plyYaw3" type="range" min="0" max="360" step="1" value="${params.plyYaw[2].toFixed(0)}">
            <div class="val" id="plyYaw3Val">${params.plyYaw[2].toFixed(0)}°</div>
          </div>
          <div class="row">
            <label for="plyYaw4">PLY 4 Yaw</label>
            <input id="plyYaw4" type="range" min="0" max="360" step="1" value="${params.plyYaw[3].toFixed(0)}">
            <div class="val" id="plyYaw4Val">${params.plyYaw[3].toFixed(0)}°</div>
          </div>
          <div class="row">
            <label for="plyYaw5">PLY 5 Yaw</label>
            <input id="plyYaw5" type="range" min="0" max="360" step="1" value="${params.plyYaw[4].toFixed(0)}">
            <div class="val" id="plyYaw5Val">${params.plyYaw[4].toFixed(0)}°</div>
          </div>
        </div>

        <div class="section">
          <div class="title">Roll (Per PLY)</div>
          <div class="row">
            <label for="plyRoll1">PLY 1 Roll</label>
            <input id="plyRoll1" type="range" min="0" max="360" step="1" value="0">
            <div class="val" id="plyRoll1Val">0°</div>
          </div>
          <div class="row">
            <label for="plyRoll2">PLY 2 Roll</label>
            <input id="plyRoll2" type="range" min="0" max="360" step="1" value="0">
            <div class="val" id="plyRoll2Val">0°</div>
          </div>
          <div class="row">
            <label for="plyRoll3">PLY 3 Roll</label>
            <input id="plyRoll3" type="range" min="0" max="360" step="1" value="0">
            <div class="val" id="plyRoll3Val">0°</div>
          </div>
          <div class="row">
            <label for="plyRoll4">PLY 4 Roll</label>
            <input id="plyRoll4" type="range" min="0" max="360" step="1" value="0">
            <div class="val" id="plyRoll4Val">0°</div>
          </div>
          <div class="row">
            <label for="plyRoll5">PLY 5 Roll</label>
            <input id="plyRoll5" type="range" min="0" max="360" step="1" value="0">
            <div class="val" id="plyRoll5Val">0°</div>
          </div>
        </div>

        <div class="section">
          <div class="title">Pitch (Per PLY)</div>
          <div class="row">
            <label for="plyPitch1">PLY 1 Pitch</label>
            <input id="plyPitch1" type="range" min="0" max="360" step="1" value="0">
            <div class="val" id="plyPitch1Val">0°</div>
          </div>
          <div class="row">
            <label for="plyPitch2">PLY 2 Pitch</label>
            <input id="plyPitch2" type="range" min="0" max="360" step="1" value="0">
            <div class="val" id="plyPitch2Val">0°</div>
          </div>
          <div class="row">
            <label for="plyPitch3">PLY 3 Pitch</label>
            <input id="plyPitch3" type="range" min="0" max="360" step="1" value="0">
            <div class="val" id="plyPitch3Val">0°</div>
          </div>
          <div class="row">
            <label for="plyPitch4">PLY 4 Pitch</label>
            <input id="plyPitch4" type="range" min="0" max="360" step="1" value="0">
            <div class="val" id="plyPitch4Val">0°</div>
          </div>
          <div class="row">
            <label for="plyPitch5">PLY 5 Pitch</label>
            <input id="plyPitch5" type="range" min="0" max="360" step="1" value="0">
            <div class="val" id="plyPitch5Val">0°</div>
          </div>
        </div>

        <div class="section">
          <div class="title">H-Line (Per PLY)</div>
          <div class="row">
            <label for="plyH1">PLY 1 H</label>
            <input id="plyH1" type="range" min="0" max="360" step="1" value="0">
            <div class="val" id="plyH1Val">0°</div>
          </div>
          <div class="row">
            <label for="plyH2">PLY 2 H</label>
            <input id="plyH2" type="range" min="0" max="360" step="1" value="0">
            <div class="val" id="plyH2Val">0°</div>
          </div>
          <div class="row">
            <label for="plyH3">PLY 3 H</label>
            <input id="plyH3" type="range" min="0" max="360" step="1" value="0">
            <div class="val" id="plyH3Val">0°</div>
          </div>
          <div class="row">
            <label for="plyH4">PLY 4 H</label>
            <input id="plyH4" type="range" min="0" max="360" step="1" value="0">
            <div class="val" id="plyH4Val">0°</div>
          </div>
          <div class="row">
            <label for="plyH5">PLY 5 H</label>
            <input id="plyH5" type="range" min="0" max="360" step="1" value="0">
            <div class="val" id="plyH5Val">0°</div>
          </div>
        </div>
      `;
      document.body.appendChild(ui);

      function updateBackground() {
        // Update both scene and page backgrounds
        const c = params.bgColor;
        if (scene.background && scene.background.isColor) {
          scene.background.set(c);
        } else {
          scene.background = new THREE.Color(c);
        }
        document.body.style.background = c;
        document.documentElement.style.background = c;
      }

      function bindSlider(id, key) {
        const el = document.getElementById(id);
        const val = document.getElementById(id + 'Val');
        el.addEventListener('input', () => {
          params[key] = parseFloat(el.value);
          if (key === 'pointSize') {
            val.textContent = params[key].toFixed(1) + ' px';
          } else if (key === 'pointScale') {
            val.textContent = params[key].toFixed(2) + '×';
          } else if (key === 'globalYaw' || key === 'globalPitch' || key === 'globalRoll' || key === 'globalH') {
            val.textContent = params[key].toFixed(0) + '°';
          } else if (key === 'globalD' || key === 'globalUD' || key === 'globalLR' || key === 'dBase') {
            val.textContent = params[key].toFixed(2);
          } else {
            val.textContent = params[key].toFixed(2);
          }
          updateLayout();
          syncURL();
        });
      }
      function bindImgSlider(id, idx) {
        if (!params.plyImgAlpha) params.plyImgAlpha = Array.from({ length: COUNT }, () => 1);
        const el = document.getElementById(id);
        const val = document.getElementById(id + 'Val');
        el.addEventListener('input', () => {
          let v = parseFloat(el.value);
          if (isNaN(v)) v = 1;
          v = Math.max(0, Math.min(1, v));
          params.plyImgAlpha[idx] = v;
          val.textContent = v.toFixed(2);
          updateLayout();
          syncURL();
        });
      }
      function bindCheckbox(id, key) {
        const el = document.getElementById(id);
        const val = document.getElementById(id + 'Val');
        const update = () => {
          params[key] = !!el.checked;
          val.textContent = params[key] ? 'ON' : 'OFF';
          updateLayout();
          syncURL();
        };
        el.addEventListener('change', update);
        update();
      }
      function bindAngleSlider(id, arr, idx) {
        const el = document.getElementById(id);
        const val = document.getElementById(id + 'Val');
        el.addEventListener('input', () => {
          let deg = parseFloat(el.value);
          deg = ((deg % 360) + 360) % 360;
          arr[idx] = deg;
          val.textContent = `${deg.toFixed(0)}°`;
          updateLayout();
          syncURL();
        });
      }
      function bindArraySlider(id, arr, idx) {
        const el = document.getElementById(id);
        const val = document.getElementById(id + 'Val');
        el.addEventListener('input', () => {
          const v = parseFloat(el.value);
          arr[idx] = isNaN(v) ? 0 : v;
          val.textContent = `${arr[idx].toFixed(2)}`;
          updateLayout();
          syncURL();
        });
      }
      function bindColor(id, key) {
        const el = document.getElementById(id);
        const val = document.getElementById(id + 'Val');
        el.addEventListener('input', () => {
          params[key] = el.value;
          val.textContent = params[key].toUpperCase();
          updateBackground();
          syncURL();
        });
      }
      bindCheckbox('showLabels', 'showLabels');
      bindCheckbox('useCenterImage', 'useCenterImage');
      bindSlider('centerSize', 'centerSize');
      bindSlider('ringRadius', 'ringRadius');
      bindSlider('spriteHeight', 'spriteHeight');
      bindSlider('imgAlpha', 'imgAlpha');
      bindSlider('pointSize', 'pointSize');
      bindSlider('pointScale', 'pointScale');
      bindAngleSlider('plyYaw1', params.plyYaw, 0);
      bindAngleSlider('plyPitch1', params.plyPitch, 0);
      bindAngleSlider('plyRoll1', params.plyRoll, 0);
      bindArraySlider('plyD1', params.plyD, 0);
      bindArraySlider('plyUD1', params.plyUD, 0);
      bindArraySlider('plyLR1', params.plyLR, 0);
      bindAngleSlider('plyYaw2', params.plyYaw, 1);
      bindAngleSlider('plyPitch2', params.plyPitch, 1);
      bindAngleSlider('plyRoll2', params.plyRoll, 1);
      bindArraySlider('plyD2', params.plyD, 1);
      bindArraySlider('plyUD2', params.plyUD, 1);
      bindArraySlider('plyLR2', params.plyLR, 1);
      bindAngleSlider('plyYaw3', params.plyYaw, 2);
      bindAngleSlider('plyPitch3', params.plyPitch, 2);
      bindAngleSlider('plyRoll3', params.plyRoll, 2);
      bindArraySlider('plyD3', params.plyD, 2);
      bindArraySlider('plyUD3', params.plyUD, 2);
      bindArraySlider('plyLR3', params.plyLR, 2);
      bindAngleSlider('plyYaw4', params.plyYaw, 3);
      bindAngleSlider('plyPitch4', params.plyPitch, 3);
      bindAngleSlider('plyRoll4', params.plyRoll, 3);
      bindArraySlider('plyD4', params.plyD, 3);
      bindArraySlider('plyUD4', params.plyUD, 3);
      bindArraySlider('plyLR4', params.plyLR, 3);
      bindAngleSlider('plyYaw5', params.plyYaw, 4);
      bindAngleSlider('plyPitch5', params.plyPitch, 4);
      bindAngleSlider('plyRoll5', params.plyRoll, 4);
      bindArraySlider('plyD5', params.plyD, 4);
      bindArraySlider('plyUD5', params.plyUD, 4);
      bindArraySlider('plyLR5', params.plyLR, 4);
      bindSlider('globalYaw', 'globalYaw');
      bindSlider('globalPitch', 'globalPitch');
      bindSlider('globalRoll', 'globalRoll');
      bindSlider('globalH', 'globalH');
      bindSlider('globalD', 'globalD');
      bindSlider('globalUD', 'globalUD');
      bindSlider('globalLR', 'globalLR');
      bindSlider('dBase', 'dBase');
      bindImgSlider('img1', 0);
      bindImgSlider('img2', 1);
      bindImgSlider('img3', 2);
      bindImgSlider('img4', 3);
      bindImgSlider('img5', 4);
      bindAngleSlider('plyH1', params.plyH, 0);
      bindAngleSlider('plyH2', params.plyH, 1);
      bindAngleSlider('plyH3', params.plyH, 2);
      bindAngleSlider('plyH4', params.plyH, 3);
      bindAngleSlider('plyH5', params.plyH, 4);
      bindColor('bgColor', 'bgColor');
      // initialize background from default
      updateBackground();

      // ---- URL sync (serialize only when deviating from defaults) ----
      function arraysEqual(a, b) {
        if (!a || !b || a.length !== b.length) return false;
        for (let i = 0; i < a.length; i++) if (a[i] !== b[i]) return false;
        return true;
      }
      function round(n, d = 2) {
        const p = Math.pow(10, d);
        return Math.round(n * p) / p;
      }
      const CSV_DELIM = ';';
      function toCSVInt(arr) { return arr.map(v => Math.round(v)).join(CSV_DELIM); }
      function toCSVFloat(arr, dp = 2) {
        return arr.map(v => round(parseFloat(v) || 0, dp)).join(CSV_DELIM);
      }
      function syncURL() {
        const sp = new URLSearchParams();
        // Scalars
        if (params.centerSize !== DEFAULTS.centerSize) sp.set('centerSize', String(round(params.centerSize)));
        if (params.ringRadius !== DEFAULTS.ringRadius) sp.set('ringRadius', String(round(params.ringRadius)));
        if (params.spriteHeight !== DEFAULTS.spriteHeight) sp.set('spriteHeight', String(round(params.spriteHeight)));
        if (params.pointSize !== DEFAULTS.pointSize) sp.set('pointSize', String(round(params.pointSize, 1)));
        if (params.pointScale !== DEFAULTS.pointScale) sp.set('pointScale', String(round(params.pointScale)));
        if ((params.bgColor || '').toLowerCase() !== (DEFAULTS.bgColor || '').toLowerCase()) sp.set('bgColor', params.bgColor);
        if (params.useCenterImage !== DEFAULTS.useCenterImage) sp.set('useCenterImage', params.useCenterImage ? '1' : '0');
        if (params.showLabels !== DEFAULTS.showLabels) sp.set('showLabels', params.showLabels ? '1' : '0');
        if (params.imgAlpha !== DEFAULTS.imgAlpha) sp.set('imgAlpha', String(round(params.imgAlpha, 2)));
        if (params.globalYaw !== DEFAULTS.globalYaw) sp.set('globalYaw', String(Math.round(params.globalYaw)));
        if (params.globalRoll !== DEFAULTS.globalRoll) sp.set('globalRoll', String(Math.round(params.globalRoll)));
        if (params.globalPitch !== DEFAULTS.globalPitch) sp.set('globalPitch', String(Math.round(params.globalPitch)));
        if (params.globalH !== DEFAULTS.globalH) sp.set('globalH', String(Math.round(params.globalH)));
        if (params.globalD !== DEFAULTS.globalD) sp.set('globalD', String(round(params.globalD)));
        if (params.globalUD !== DEFAULTS.globalUD) sp.set('globalUD', String(round(params.globalUD)));
        if (params.globalLR !== DEFAULTS.globalLR) sp.set('globalLR', String(round(params.globalLR)));
        if (params.dBase !== DEFAULTS.dBase) sp.set('dBase', String(round(params.dBase)));
        // Arrays
        if (!arraysEqual(params.plyYaw, DEFAULT_ARR.yaw)) sp.set('yaw', toCSVInt(params.plyYaw));
        if (!arraysEqual(params.plyRoll, DEFAULT_ARR.roll)) sp.set('roll', toCSVInt(params.plyRoll));
        if (!arraysEqual(params.plyPitch, DEFAULT_ARR.pitch)) sp.set('pitch', toCSVInt(params.plyPitch));
        if (!arraysEqual(params.plyH, DEFAULT_ARR.h)) sp.set('h', toCSVInt(params.plyH));
        // Always include D/UD/LR arrays, even if equal to defaults
        sp.set('d', toCSVFloat(params.plyD || DEFAULT_ARR.d, 2));
        sp.set('ud', toCSVFloat(params.plyUD || DEFAULT_ARR.ud, 2));
        sp.set('lr', toCSVFloat(params.plyLR || DEFAULT_ARR.lr, 2));
        if (!arraysEqual(params.plyImgAlpha || DEFAULT_ARR.img, DEFAULT_ARR.img)) sp.set('img', toCSVFloat(params.plyImgAlpha || DEFAULT_ARR.img, 2));
        // Replace URL without reloading
        const base = location.origin + location.pathname;
        const query = sp.toString();
        const hash = location.hash || '';
        const url = query ? `${base}?${query}${hash}` : `${base}${hash}`;
        history.replaceState(null, '', url);
      }
    </script>
  </body>
 </html>
