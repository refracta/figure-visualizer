<!doctype html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Three.js Pentagonal Gallery with PLY</title>
    <style>
      html, body { margin: 0; height: 100%; overflow: hidden; background: #ffffff; }
      #info {
        position: absolute; top: 10px; left: 10px; color: #e6e6e6; font: 13px/1.3 system-ui, -apple-system, Segoe UI, Roboto, Arial;
        background: rgba(0,0,0,0.45); padding: 8px 10px; border-radius: 8px; user-select: none;
      }
      #info a { color: #9dd7ff; text-decoration: none; }
      #ui {
        position: absolute; top: 10px; right: 10px; color: #e6e6e6; font: 12px/1.25 system-ui, -apple-system, Segoe UI, Roboto, Arial;
        background: rgba(0,0,0,0.55); padding: 10px 12px; border-radius: 10px; width: 260px; box-shadow: 0 4px 16px rgba(0,0,0,0.25);
      }
      #ui .row { display: grid; grid-template-columns: 1fr 3fr 48px; gap: 8px; align-items: center; margin: 6px 0; }
      #ui label { color: #c9d1d9; }
      #ui input[type="range"] { width: 100%; }
      #ui .val { text-align: right; font-variant-numeric: tabular-nums; color: #9fb3c8; }
    </style>
    <!-- Using ES modules from CDN (examples/jsm) -->
  </head>
  <body>
    <div id="info">
      <div>마우스 드래그: 회전 · 휠: 줌 · 우클릭: 팬</div>
      <div>이미지: <code>resources/image/1.png..5.png</code> · PLY: <code>resources/ply/1.ply..5.ply</code></div>
    </div>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.159.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.159.0/examples/jsm/"
        }
      }
    </script>
    <script type="module">
      import * as THREE from 'three';
      import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
      import { PLYLoader } from 'three/addons/loaders/PLYLoader.js';

      // ----- basic scene -----
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0xffffff);

      const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 1.6, 7);

      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      document.body.appendChild(renderer.domElement);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.06;
      controls.minDistance = 2.2;
      controls.maxDistance = 20;
      controls.target.set(0, 0, 0);

      // ----- lighting -----
      const hemi = new THREE.HemisphereLight(0xffffff, 0x111122, 0.6);
      scene.add(hemi);
      const dir = new THREE.DirectionalLight(0xffffff, 0.9);
      dir.position.set(5, 6, 4);
      scene.add(dir);

      // ----- center red sphere -----
      const SPHERE_BASE_RADIUS = 0.5; // default/base; UI scales this
      const sphereGeo = new THREE.SphereGeometry(SPHERE_BASE_RADIUS, 48, 32);
      const sphereMat = new THREE.MeshStandardMaterial({ color: 0xff3333, roughness: 0.6, metalness: 0.05 });
      const sphere = new THREE.Mesh(sphereGeo, sphereMat);
      sphere.castShadow = false;
      sphere.receiveShadow = false;
      scene.add(sphere);

      // ----- layout parameters -----
      const COUNT = 5;
      const PLY_OFFSET = 0.28; // how much further the PLY sits behind the image (away from center)
      const ELEVATION = 0.0; // y-position for both images and PLYs
      const DEFAULTS = { sphereRadius: SPHERE_BASE_RADIUS, ringRadius: 2.8, spriteHeight: 2.0, pointSize: 3.0, pointScale: 1.0 };
      const params = { ...DEFAULTS };

      const group = new THREE.Group();
      scene.add(group);

      // helpers
      const texLoader = new THREE.TextureLoader();
      const plyLoader = new PLYLoader();

      // storage for created meshes for interactive updates
      const planes = new Array(COUNT); // { mesh, aspect }
      const models = new Array(COUNT); // { mesh }

      function polarPosition(radius, angle, y = 0) {
        return new THREE.Vector3(
          Math.cos(angle) * radius,
          y,
          Math.sin(angle) * radius
        );
      }

      function updateLayout() {
        // update sphere size via scaling
        const sphereScale = params.sphereRadius / SPHERE_BASE_RADIUS;
        sphere.scale.setScalar(sphereScale);

        for (let k = 0; k < COUNT; k++) {
          const angleVertex = (k / COUNT) * Math.PI * 2 - Math.PI / 2;
          const angle = angleVertex + Math.PI / COUNT; // edge midpoint

          const p = planes[k];
          if (p && p.mesh) {
            p.mesh.position.copy(polarPosition(params.ringRadius, angle, ELEVATION));
            p.mesh.lookAt(0, ELEVATION, 0);
            p.mesh.scale.set(params.spriteHeight * p.aspect, params.spriteHeight, 1);
          }

          const m = models[k];
          if (m && m.mesh) {
            m.mesh.position.copy(polarPosition(params.ringRadius + PLY_OFFSET, angle, ELEVATION));
            m.mesh.lookAt(0, ELEVATION, 0);
            if (m.baseScale) {
              m.mesh.scale.setScalar(m.baseScale * params.pointScale);
            }
            if (m.mesh.material && 'size' in m.mesh.material) {
              m.mesh.material.size = params.pointSize;
              m.mesh.material.needsUpdate = true;
            }
          }
        }
      }

      function addSpriteWithPLY(index) {
        const i = index + 1; // 1..5
        const angleVertex = (index / COUNT) * Math.PI * 2 - Math.PI / 2; // vertex angle, start at top
        const angle = angleVertex + Math.PI / COUNT; // shift to edge midpoint

        // Image as Plane (PNG) placed at edge midpoint and oriented along edge direction (tangent)
        const pngPath = `resources/image/${i}.png`;
        texLoader.load(
          pngPath,
          (tex) => {
            tex.colorSpace = THREE.SRGBColorSpace;
            const aspect = tex.image ? (tex.image.width / tex.image.height) : 1;
            const geo = new THREE.PlaneGeometry(1, 1); // scale to size later
            const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true, alphaTest: 0.06, depthWrite: false, side: THREE.DoubleSide });
            const plane = new THREE.Mesh(geo, mat);
            plane.position.copy(polarPosition(params.ringRadius, angle, ELEVATION));
            // Face toward center so local X aligns with tangential direction
            plane.lookAt(0, ELEVATION, 0);
            plane.scale.set(params.spriteHeight * aspect, params.spriteHeight, 1);
            group.add(plane);
            planes[index] = { mesh: plane, aspect };
          },
          undefined,
          (err) => {
            console.warn(`PNG 로드 실패: ${pngPath}`, err);
          }
        );

        // PLY (behind the sprite, further from center)
        const plyPath = `resources/ply/${i}.ply`;
        plyLoader.load(
          plyPath,
          (geom) => {
            // Points with per-vertex color; no normals needed
            const mat = new THREE.PointsMaterial({ vertexColors: true, size: params.pointSize, sizeAttenuation: false });
            const points = new THREE.Points(geom, mat);

            // Fit model to a target radius for consistency
            geom.computeBoundingSphere();
            const bs = geom.boundingSphere;
            let baseScale = 1.0;
            if (bs && bs.radius > 0) {
              const target = 0.6; // target bounding sphere radius in world units
              baseScale = target / bs.radius;
            }
            points.scale.setScalar(baseScale * params.pointScale);

            const base = polarPosition(params.ringRadius + PLY_OFFSET, angle, ELEVATION);
            points.position.copy(base);

            // Face toward center (orientation not critical for points)
            points.lookAt(0, ELEVATION, 0);

            group.add(points);
            models[index] = { mesh: points, baseScale };
          },
          undefined,
          (err) => {
            console.warn(`PLY 로드 실패: ${plyPath}`, err);
          }
        );
      }

      for (let k = 0; k < COUNT; k++) addSpriteWithPLY(k);

      // resize
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // animate
      const clock = new THREE.Clock();
      function tick() {
        const dt = clock.getDelta();
        controls.update();
        renderer.render(scene, camera);
        requestAnimationFrame(tick);
      }
      tick();

      // ----- UI (sliders) -----
      const ui = document.createElement('div');
      ui.id = 'ui';
      ui.innerHTML = `
        <div class="row">
          <label for="sphereRadius">Sphere Radius</label>
          <input id="sphereRadius" type="range" min="0.1" max="1.5" step="0.01" value="${DEFAULTS.sphereRadius}">
          <div class="val" id="sphereRadiusVal">${DEFAULTS.sphereRadius.toFixed(2)}</div>
        </div>
        <div class="row">
          <label for="ringRadius">Image Distance</label>
          <input id="ringRadius" type="range" min="1.0" max="6.0" step="0.01" value="${DEFAULTS.ringRadius}">
          <div class="val" id="ringRadiusVal">${DEFAULTS.ringRadius.toFixed(2)}</div>
        </div>
        <div class="row">
          <label for="spriteHeight">Image Size</label>
          <input id="spriteHeight" type="range" min="0.2" max="2.5" step="0.01" value="${DEFAULTS.spriteHeight}">
          <div class="val" id="spriteHeightVal">${DEFAULTS.spriteHeight.toFixed(2)}</div>
        </div>
        <div class="row">
          <label for="pointSize">Point Size</label>
          <input id="pointSize" type="range" min="1" max="10" step="0.1" value="${DEFAULTS.pointSize}">
          <div class="val" id="pointSizeVal">${DEFAULTS.pointSize.toFixed(1)} px</div>
        </div>
        <div class="row">
          <label for="pointScale">Point Cloud Scale</label>
          <input id="pointScale" type="range" min="0.2" max="3.0" step="0.01" value="${DEFAULTS.pointScale}">
          <div class="val" id="pointScaleVal">${DEFAULTS.pointScale.toFixed(2)}×</div>
        </div>
      `;
      document.body.appendChild(ui);

      function bindSlider(id, key) {
        const el = document.getElementById(id);
        const val = document.getElementById(id + 'Val');
        el.addEventListener('input', () => {
          params[key] = parseFloat(el.value);
          if (key === 'pointSize') {
            val.textContent = params[key].toFixed(1) + ' px';
          } else if (key === 'pointScale') {
            val.textContent = params[key].toFixed(2) + '×';
          } else {
            val.textContent = params[key].toFixed(2);
          }
          updateLayout();
        });
      }
      bindSlider('sphereRadius', 'sphereRadius');
      bindSlider('ringRadius', 'ringRadius');
      bindSlider('spriteHeight', 'spriteHeight');
      bindSlider('pointSize', 'pointSize');
      bindSlider('pointScale', 'pointScale');
    </script>
  </body>
 </html>
