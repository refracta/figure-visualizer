<!doctype html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Three.js Pentagonal Gallery with PLY</title>
    <style>
      html, body { margin: 0; height: 100%; overflow: hidden; background: #0f1115; }
      #info {
        position: absolute; top: 10px; left: 10px; color: #e6e6e6; font: 13px/1.3 system-ui, -apple-system, Segoe UI, Roboto, Arial;
        background: rgba(0,0,0,0.45); padding: 8px 10px; border-radius: 8px; user-select: none;
      }
      #info a { color: #9dd7ff; text-decoration: none; }
    </style>
    <!-- Using ES modules from CDN (examples/jsm) -->
  </head>
  <body>
    <div id="info">
      <div>마우스 드래그: 회전 · 휠: 줌 · 우클릭: 팬</div>
      <div>이미지: <code>resources/image/1.png..5.png</code> · PLY: <code>resources/ply/1.ply..5.ply</code></div>
    </div>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.159.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.159.0/examples/jsm/"
        }
      }
    </script>
    <script type="module">
      import * as THREE from 'three';
      import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
      import { PLYLoader } from 'three/addons/loaders/PLYLoader.js';

      // ----- basic scene -----
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0f1115);

      const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 1.6, 7);

      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      document.body.appendChild(renderer.domElement);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.06;
      controls.minDistance = 2.2;
      controls.maxDistance = 20;
      controls.target.set(0, 0, 0);

      // ----- lighting -----
      const hemi = new THREE.HemisphereLight(0xffffff, 0x111122, 0.6);
      scene.add(hemi);
      const dir = new THREE.DirectionalLight(0xffffff, 0.9);
      dir.position.set(5, 6, 4);
      scene.add(dir);

      // ----- center red sphere -----
      const SPHERE_RADIUS = 1.0;
      const sphereGeo = new THREE.SphereGeometry(SPHERE_RADIUS, 48, 32);
      const sphereMat = new THREE.MeshStandardMaterial({ color: 0xff3333, roughness: 0.6, metalness: 0.05 });
      const sphere = new THREE.Mesh(sphereGeo, sphereMat);
      sphere.castShadow = false;
      sphere.receiveShadow = false;
      scene.add(sphere);

      // ----- layout parameters -----
      const COUNT = 5;
      const RING_RADIUS = 2.6; // distance of images from center
      const PLY_OFFSET = 0.28; // how much further the PLY sits behind the image (away from center)
      const SPRITE_HEIGHT = 1.1; // world units; width auto by aspect
      const ELEVATION = 0.0; // y-position for both images and PLYs

      const group = new THREE.Group();
      scene.add(group);

      // helpers
      const texLoader = new THREE.TextureLoader();
      const plyLoader = new PLYLoader();

      function polarPosition(radius, angle, y = 0) {
        return new THREE.Vector3(
          Math.cos(angle) * radius,
          y,
          Math.sin(angle) * radius
        );
      }

      function addSpriteWithPLY(index) {
        const i = index + 1; // 1..5
        const angle = (index / COUNT) * Math.PI * 2 - Math.PI / 2; // start at top

        // Sprite (PNG)
        const pngPath = `resources/image/${i}.png`;
        texLoader.load(
          pngPath,
          (tex) => {
            tex.colorSpace = THREE.SRGBColorSpace;
            const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthTest: true, depthWrite: false });
            const sprite = new THREE.Sprite(mat);
            const pos = polarPosition(RING_RADIUS, angle, ELEVATION);
            sprite.position.copy(pos);
            // Scale sprite to a fixed height, keep aspect
            const aspect = tex.image ? (tex.image.width / tex.image.height) : 1;
            sprite.scale.set(SPRITE_HEIGHT * aspect, SPRITE_HEIGHT, 1);
            group.add(sprite);
          },
          undefined,
          (err) => {
            console.warn(`PNG 로드 실패: ${pngPath}`, err);
          }
        );

        // PLY (behind the sprite, further from center)
        const plyPath = `resources/ply/${i}.ply`;
        plyLoader.load(
          plyPath,
          (geom) => {
            const mat = new THREE.MeshStandardMaterial({ color: 0xdddddd, roughness: 0.9, metalness: 0.0 });
            const mesh = new THREE.Mesh(geom, mat);

            // Fit model to a target radius for consistency
            geom.computeBoundingSphere();
            const bs = geom.boundingSphere;
            if (bs && bs.radius > 0) {
              const target = 0.6; // target bounding sphere radius in world units
              const s = target / bs.radius;
              mesh.scale.setScalar(s);
            }

            const base = polarPosition(RING_RADIUS + PLY_OFFSET, angle, ELEVATION);
            mesh.position.copy(base);

            // Face toward center
            mesh.lookAt(0, ELEVATION, 0);

            group.add(mesh);
          },
          undefined,
          (err) => {
            console.warn(`PLY 로드 실패: ${plyPath}`, err);
          }
        );
      }

      for (let k = 0; k < COUNT; k++) addSpriteWithPLY(k);

      // resize
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // animate
      const clock = new THREE.Clock();
      function tick() {
        const dt = clock.getDelta();
        controls.update();
        renderer.render(scene, camera);
        requestAnimationFrame(tick);
      }
      tick();
    </script>
  </body>
 </html>
